#include "hal_data.h"
#include "SerialCompatibility.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

fsp_err_t spi_init(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status

    /* Open/Initialize SPI Slave module */
    err = R_RSPI_Open (&g_spi0_ctrl, &g_spi0_cfg);
    /* handle error */
    if (FSP_SUCCESS != err)
    {
        /* SPI Slave Failure message */
        Serial.print((uint8_t*)"** R_RSPI_Open API for SPI Master failed **\n");
    }
    return err;
}

#define BUFF_LEN (32)
#define MAX_COUNT (0xFFFF)
#define RESET_VALUE 0

static volatile uint32_t g_wait_count = MAX_COUNT;

static volatile spi_event_t g_slave_event_flag;     // Slave Transfer Event completion flag

static uint8_t g_slave_tx_buff[BUFF_LEN];    // Slave Transmit Buffer
static uint8_t g_slave_rx_buff[BUFF_LEN];    // Slave Receive Buffer

fsp_err_t spi_write_read(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status
    /* Number of bytes read by SEGGER real-time-terminal for master and slave inputs */
    uint32_t num_bytes_master = RESET_VALUE;
    uint32_t num_bytes_slave = RESET_VALUE;

    /* Cleaning buffers */
    memset(&g_slave_tx_buff[0], 0, sizeof(g_slave_tx_buff));
    memset(&g_slave_rx_buff[0], 0, sizeof(g_slave_rx_buff));

    num_bytes_slave = 1;
    g_slave_tx_buff[0] = 0x00;

    /* Slave send data to Master and receive data from Master */
    err = R_RSPI_WriteRead(&g_spi0_ctrl, g_slave_tx_buff, g_slave_rx_buff, 1, SPI_BIT_WIDTH_8_BITS);

    if (FSP_SUCCESS != err)
    {
            //APP_PRINT("error code %d\n", (int)err);
        Serial.print((uint8_t*)"Slave R_RSPI_Write() failed\n");
        Serial.println(err);
        return err;
    }

    while((SPI_EVENT_TRANSFER_COMPLETE != g_slave_event_flag))
        {
            /* Timer out operation if SPI operation fails to complete */
            g_wait_count--;
            if (0 >= g_wait_count)
            {
                Serial.print((uint8_t*)"TIMEOUT WRITE\n");
                err = FSP_ERR_TIMEOUT;
                //return err;
                break;
            }
            else if ((SPI_EVENT_TRANSFER_ABORTED == g_slave_event_flag))
            {
                Serial.print((uint8_t*)"ABORTED\n");
                err = FSP_ERR_TRANSFER_ABORTED;
                Serial.print((uint8_t*)"SPI module failed in Write operation.\n");
                return err;
            }
        }

    Serial.print((uint8_t*)"RESULT1: "); Serial.println(g_slave_rx_buff[0]);
    Serial.print((uint8_t*)"RESULT2: "); Serial.println(g_slave_rx_buff[1]);
    Serial.print((uint8_t*)"RESULT3: "); Serial.println(g_slave_rx_buff[2]);

    g_wait_count = MAX_COUNT;

    g_slave_event_flag  = (spi_event_t) RESET_VALUE;  // Reseting slave_event flag

    /* Delay of one second for user to verify the output */

    return FSP_SUCCESS;
}

void spi_clean_up(void)
{
    fsp_err_t err = FSP_SUCCESS;

    err = R_RSPI_Close(&g_spi0_ctrl);
    /* handle error */
    if (FSP_SUCCESS != err)
    {
        /* SPI Close failure message */
        Serial.print((uint8_t*)"** R_RSPI_Close API for slave failed **\n");
    }
}

void spi_slave_callback(spi_callback_args_t * p_args)
{
    if (SPI_EVENT_TRANSFER_COMPLETE == p_args->event)
    {
        g_slave_event_flag = SPI_EVENT_TRANSFER_COMPLETE;
    }
    else
    {
        g_slave_event_flag = SPI_EVENT_TRANSFER_ABORTED;
    }
}

/*******************************************************************************************************************//**
 * main() is generated by the RZA3UL Configuration editor and is used to generate threads if an RTOS is used.
 * This function is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
    R_BSP_PinAccessEnable();

    Serial.begin(115200);

    while (1)
    {
        spi_init();
        spi_write_read();
        spi_clean_up();
        R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_SECONDS);
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
        /* Initialize MMU. */
        R_MMU_Open (&g_mmu_ctrl, &g_mmu_cfg);
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, &g_bsp_pin_cfg);
    }
}
